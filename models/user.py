# models/user.py
# User model with enhanced roles and approval system for Super Admin, Partner, and Agent

from datetime import datetime
from bson import ObjectId
import bcrypt

class User:
    def __init__(self, data=None):
        if data:
            self._id = data.get('_id')
            self.username = data.get('username')
            self.email = data.get('email')
            self.password = data.get('password')
            self.full_name = data.get('full_name')
            self.phone = data.get('phone')
            self.role = data.get('role', 'AGENT')  # SUPER_ADMIN, PARTNER, AGENT
            self.profile_image = data.get('profile_image')
            self.is_active = data.get('is_active', True)
            
            # Partner-specific fields
            self.partner_id = data.get('partner_id')  # For agents - which partner they belong to
            self.assigned_plans = data.get('assigned_plans', [])  # For partners - plans they can use
            self.assigned_coupons = data.get('assigned_coupons', [])  # For partners - coupons they can use
            self.pdf_limit = data.get('pdf_limit', 0)  # Overall PDF limit for partner
            self.pdf_generated = data.get('pdf_generated', 0)  # PDFs generated by partner's agents
            
            # Agent-specific fields
            self.plan_id = data.get('plan_id')  # For agents
            self.plan_start_date = data.get('plan_start_date')
            self.plan_expiry_date = data.get('plan_expiry_date')
            self.agent_pdf_generated = data.get('agent_pdf_generated', 0)
            self.agent_pdf_limit = data.get('agent_pdf_limit', 0)
            
            # Approval fields
            self.approval_status = data.get('approval_status', 'PENDING')  # PENDING, PARTNER_APPROVED, APPROVED, REJECTED
            self.requires_double_approval = data.get('requires_double_approval', True)
            self.partner_approved = data.get('partner_approved', False)
            self.partner_approved_at = data.get('partner_approved_at')
            self.partner_approved_by = data.get('partner_approved_by')
            self.super_admin_approved = data.get('super_admin_approved', False)
            self.super_admin_approved_at = data.get('super_admin_approved_at')
            self.super_admin_approved_by = data.get('super_admin_approved_by')
            self.rejection_reason = data.get('rejection_reason')
            
            # Registration link tracking
            self.registration_link = data.get('registration_link')
            self.registered_via_link = data.get('registered_via_link')
            self.registration_link_sent_by = data.get('registration_link_sent_by')
            
            # Timestamps
            self.created_at = data.get('created_at', datetime.utcnow())
            self.updated_at = data.get('updated_at', datetime.utcnow())
            self.last_login = data.get('last_login')
            self.created_by = data.get('created_by')
    
    def to_dict(self):
        return {
            'username': self.username,
            'email': self.email,
            'password': self.password,
            'full_name': self.full_name,
            'phone': self.phone,
            'role': self.role,
            'profile_image': self.profile_image,
            'is_active': self.is_active,
            'partner_id': self.partner_id,
            'assigned_plans': self.assigned_plans,
            'assigned_coupons': self.assigned_coupons,
            'pdf_limit': self.pdf_limit,
            'pdf_generated': self.pdf_generated,
            'plan_id': self.plan_id,
            'plan_start_date': self.plan_start_date,
            'plan_expiry_date': self.plan_expiry_date,
            'agent_pdf_generated': self.agent_pdf_generated,
            'agent_pdf_limit': self.agent_pdf_limit,
            'approval_status': self.approval_status,
            'requires_double_approval': self.requires_double_approval,
            'partner_approved': self.partner_approved,
            'partner_approved_at': self.partner_approved_at,
            'partner_approved_by': self.partner_approved_by,
            'super_admin_approved': self.super_admin_approved,
            'super_admin_approved_at': self.super_admin_approved_at,
            'super_admin_approved_by': self.super_admin_approved_by,
            'rejection_reason': self.rejection_reason,
            'registration_link': self.registration_link,
            'registered_via_link': self.registered_via_link,
            'registration_link_sent_by': self.registration_link_sent_by,
            'created_at': self.created_at,
            'updated_at': self.updated_at,
            'last_login': self.last_login,
            'created_by': self.created_by
        }
    
    @staticmethod
    def hash_password(password):
        return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
    
    @staticmethod
    def verify_password(password, hashed):
        return bcrypt.checkpw(password.encode('utf-8'), hashed)
    
    @property
    def id(self):
        return str(self._id) if self._id else None
    
    @property
    def is_authenticated(self):
        return True
    
    @property
    def is_anonymous(self):
        return False
    
    def get_id(self):
        return str(self._id)
    
    def has_role(self, role):
        return self.role == role
    
    def is_super_admin(self):
        return self.role == 'SUPER_ADMIN'
    
    def is_partner(self):
        return self.role == 'PARTNER'
    
    def is_agent(self):
        return self.role == 'AGENT'
    
    def is_admin(self):
        """For backward compatibility - includes both super admin and partner"""
        return self.role in ['SUPER_ADMIN', 'PARTNER']
    
    def is_owner(self):
        """For backward compatibility - maps to super admin"""
        return self.role == 'SUPER_ADMIN'
    
    def can_login(self):
        """Check if user can login based on approval status"""
        if self.role == 'SUPER_ADMIN':
            return self.is_active
        
        if self.role == 'PARTNER':
            if self.requires_double_approval:
                return self.is_active and self.super_admin_approved
            else:
                return self.is_active
        
        if self.role == 'AGENT':
            if self.requires_double_approval:
                return self.is_active and self.partner_approved and self.super_admin_approved
            else:
                return self.is_active and (self.partner_approved or self.super_admin_approved)
        
        return False
    
    def get_approval_status_display(self):
        """Get human-readable approval status"""
        if self.approval_status == 'APPROVED':
            return 'Approved'
        elif self.approval_status == 'REJECTED':
            return f'Rejected: {self.rejection_reason or "No reason provided"}'
        elif self.approval_status == 'PARTNER_APPROVED':
            return 'Partner Approved (Awaiting Super Admin)'
        else:
            return 'Pending Approval'